/* :ts=8			preferences.c
 *
 *    cp4 - Commodore C+4 emulator
 *    Copyright (C) 1998 Gáti Gergely
 *
 *    This program is free software; you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
 *    the Free Software Foundation; either version 2 of the License, or
 *    (at your option) any later version.
 *
 *    This program is distributed in the hope that it will be useful,
 *    but WITHOUT ANY WARRANTY; without even the implied warranty of
 *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *    GNU General Public License for more details.
 *
 *    You should have received a copy of the GNU General Public License
 *    along with this program; if not, write to the Free Software Foundation,
 *    Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 *
 *    e-mail: gatig@dragon.klte.hu
 *
 *
 *  Source machine generated by GadToolsBox V2.0b
 *  which is (c) Copyright 1991-1993 Jaba Development
 *
 *  GUI Designed by : Gáti Gergely
 */

#include <exec/types.h>
#include <intuition/intuition.h>
#include <intuition/classes.h>
#include <intuition/classusr.h>
#include <intuition/imageclass.h>
#include <intuition/gadgetclass.h>
#include <libraries/gadtools.h>
#include <proto/graphics.h>
#include <proto/exec.h>
#include <proto/dos.h>
#include <graphics/displayinfo.h>
#include <graphics/gfxbase.h>
#include <clib/exec_protos.h>
#include <clib/intuition_protos.h>
#include <clib/gadtools_protos.h>
#include <clib/graphics_protos.h>
#include <clib/utility_protos.h>
#include <string.h>
#include <stdio.h>
#include <pragmas/exec_pragmas.h>
#include <pragmas/intuition_pragmas.h>
#include <pragmas/gadtools_pragmas.h>
#include <pragmas/graphics_pragmas.h>
#include <pragmas/utility_pragmas.h>

#include "preferences.h"

static struct Screen         *Scr = NULL;
static APTR                   VisualInfo = NULL;
static struct Window         *cp4prefsWnd = NULL;
static struct Gadget         *cp4prefsGList = NULL;
static struct Menu           *cp4prefsMenus = NULL;
struct IntuiMessage           cp4prefsMsg;
static struct Gadget         *cp4prefsGadgets[16];
static UWORD                  cp4prefsWidth = 467;
static UWORD                  cp4prefsHeight = 161;
static struct TextAttr       *Font, Attr;
static struct TextFont			 *myTextFont;
static struct TextAttr				myTextAttr;
static UWORD                  FontX, FontY;
static UWORD                  OffX, OffY;
static int OkScreen=0;

static char *cycdef[]={
	"-",
	NULL
};

static struct Node gc2pinfo0Nodes[] = {
{	&gc2pinfo0Nodes[1], ( struct Node * )&gc2pinfo0List.mlh_Head, 0, 0, "-" },
{	&gc2pinfo0Nodes[2], &gc2pinfo0Nodes[0], 0, 0, " " },
{	( struct Node * )&gc2pinfo0List.mlh_Tail, &gc2pinfo0Nodes[1], 0, 0, " " }
};

static struct MinList gc2pinfo0List = {
	( struct MinNode * )&gc2pinfo0Nodes[0], ( struct MinNode * )NULL, ( struct MinNode * )&gc2pinfo0Nodes[2] };

static UWORD cp4prefsGTypes[] = {
	BUTTON_KIND,
	TEXT_KIND,
//	CHECKBOX_KIND,
//	CHECKBOX_KIND,
//	CHECKBOX_KIND,
//	CHECKBOX_KIND,
//NEW
	CYCLE_KIND,
	CYCLE_KIND,
	BUTTON_KIND,
//NEW
	BUTTON_KIND,
	TEXT_KIND,
	TEXT_KIND,
	TEXT_KIND,
	TEXT_KIND,
	LISTVIEW_KIND,
	LISTVIEW_KIND,
	BUTTON_KIND,
	BUTTON_KIND,
	BUTTON_KIND,
	BUTTON_KIND
};

static UWORD ComputeX( UWORD value )
{
	return(( UWORD )((( FontX * value ) + 4 ) / 8 ));
}

static UWORD ComputeY(UWORD value) {
	return((UWORD)(((FontY*value)+4)/8));
}

static void ComputeFont(UWORD width, UWORD height) {
static struct IntuiText myitext;
	int x1,x2;
	Font = &Attr;
	Font->ta_Name = (STRPTR)Scr->Font->ta_Name;
	Font->ta_YSize = FontY = Scr->Font->ta_YSize;
	myitext.IText="W";
	myitext.ITextFont=Scr->Font;
	x1 = IntuiTextLength(&myitext);
	myitext.IText="M";
	x2 = IntuiTextLength(&myitext);
	if(x1>x2) FontX=x1;
	else FontX=x2;

	OffX = Scr->WBorLeft;
	OffY = Scr->Font->ta_YSize + Scr->WBorTop + 1;

	if ( width && height ) {
		if (( ComputeX( width ) + OffX + Scr->WBorRight ) > Scr->Width )
			goto UseTopaz;
		if (( ComputeY( height ) + OffY + Scr->WBorBottom ) > Scr->Height )
			goto UseTopaz;
	}
	return;

UseTopaz:
	Font->ta_Name = (STRPTR)"topaz.font";
	FontX = FontY = Font->ta_YSize = 8;
}

static int SetupScreen(void) {
	struct List *psl;
	struct Node *n;
	struct PubScreenNode *pn;

	OkScreen=0;
	psl=LockPubScreenList();
	for(n=psl->lh_Head;n->ln_Succ!=NULL;n=n->ln_Succ) {
		pn=(struct PubScreenNode *)n;
		if(pn->psn_Screen==Scr&&(pn->psn_Flags&PSNF_PRIVATE)!=PSNF_PRIVATE) {
			OkScreen=1;
			break;
		}
	}
	UnlockPubScreenList();
	if(OkScreen==0) Scr=LockPubScreen(NULL);
	ScreenToFront(Scr);
	ComputeFont(0,0);
	if(!(VisualInfo=GetVisualInfo(Scr,TAG_DONE,0L))) return(2L);
	return(0L);
}

static void CloseDownScreen( void )
{
	if(OkScreen==0) UnlockPubScreen(NULL,Scr);

	if(VisualInfo) {
		FreeVisualInfo(VisualInfo);
		VisualInfo=NULL;
	}
}

static int Handlecp4prefsIDCMP( void )
{
	struct MenuItem *n;
	struct IntuiMessage	*m;
	int			(*func)(void);
	BOOL			running = TRUE;

	while( (m = GT_GetIMsg( cp4prefsWnd->UserPort ))) {

		CopyMem(( char * )m, ( char * )&cp4prefsMsg, (long)sizeof( struct IntuiMessage ));

		GT_ReplyIMsg( m );

		switch ( cp4prefsMsg.Class ) {

			case	IDCMP_REFRESHWINDOW:
				GT_BeginRefresh( cp4prefsWnd );
				GT_EndRefresh( cp4prefsWnd, TRUE );
				break;

			case	IDCMP_CLOSEWINDOW:
				running = cp4prefsCloseWindow();
				break;

			case	IDCMP_GADGETUP:
			case	IDCMP_GADGETDOWN:
				func = ( void * )((( struct Gadget * )cp4prefsMsg.IAddress )->UserData);
				running = func();
				break;
			case	IDCMP_MENUPICK:
				while( cp4prefsMsg.Code != MENUNULL ) {
					n = ItemAddress( cp4prefsMenus, cp4prefsMsg.Code );
					func = (void *)(GTMENUITEM_USERDATA( n ));
					if(((ULONG)func)>64) running = func();
					else if(func!=NULL) handlexpkselect((int)func);
					cp4prefsMsg.Code = n->NextSelect;
				}
				break;
		}
	}
	return( running );
}

static int Opencp4prefsWindow( void )
{
	struct NewGadget	ng;
	struct Gadget	*g;
	UWORD		lc, tc;
	UWORD		wleft = DefPrfLeft, wtop, ww, wh;
	ULONG wa_top=WA_Top;
static struct MinList gc2plist0List;
struct Node gc2plist0Nodes[] = {
{	&gc2plist0Nodes[1], ( struct Node * )&gc2plist0List.mlh_Head, 0, 0, GetStr(MSG_01F5) },
{	( struct Node * )&gc2plist0List.mlh_Tail, &gc2plist0Nodes[0], 0, 0, " " }
};
struct NewMenu cp4prefsNewMenu[] = {
{	NM_TITLE, (STRPTR)GetStr(MSG_0115), NULL, 0, NULL, NULL	},
{	NM_ITEM, (STRPTR)GetStr(MSG_018A), (STRPTR)GetStr(MSG_0161), 0, 0L, (APTR)cp4prefsmpload	},
{	NM_ITEM, (STRPTR)GetStr(MSG_01F6), (STRPTR)GetStr(MSG_0260), 0, 0L, (APTR)cp4prefsmpsave	},
{	NM_ITEM, (STRPTR)NM_BARLABEL, NULL, 0, 0L, NULL	},
{	NM_ITEM, (STRPTR)GetStr(MSG_0119), NULL, 0, 0L, (APTR)cp4prefsmpreset	},
{	NM_ITEM, (STRPTR)GetStr(MSG_011A), (STRPTR)GetStr(MSG_011B), 0, 0L, (APTR)cp4prefsmpback	},
{	NM_ITEM, (STRPTR)GetStr(MSG_01F7), (STRPTR)GetStr(MSG_0261), 0, 0L, (APTR)cp4prefsmpkeymap },
{	NM_ITEM, (STRPTR)NM_BARLABEL, NULL, 0, 0L, NULL	},

// NEW 99nov22
{	NM_ITEM, (STRPTR)GetStr(MSG_0312), (STRPTR)GetStr(MSG_0313), 0, 0L, (APTR)cp4prefsmppalette },
{	NM_ITEM, (STRPTR)NM_BARLABEL, NULL, 0, 0L, NULL	},
// NEW 99nov22

// NEW oct12
{	NM_ITEM, (STRPTR)GetStr(MSG_0305), (STRPTR)GetStr(MSG_0306), 0, 0L, (APTR)cp4prefsmpmakesnapshot },
{	NM_ITEM, (STRPTR)GetStr(MSG_0307), (STRPTR)GetStr(MSG_0308), 0, 0L, (APTR)cp4prefsmploadsnapshot },
{	NM_ITEM, (STRPTR)NM_BARLABEL, NULL, 0, 0L, NULL	},
// NEW oct12

{	NM_ITEM, (STRPTR)GetStr(MSG_01F8), (STRPTR)GetStr(MSG_01F9), 0, 0L, (APTR)cp4prefsmpabout },
{	NM_ITEM, (STRPTR)NM_BARLABEL, NULL, 0, 0L, NULL	},
{	NM_ITEM, (STRPTR)GetStr(MSG_011C), NULL, 0, 0L, (APTR)cp4prefsmpquit	},

{	NM_TITLE, (STRPTR)GetStr(MSG_018B), NULL, 0, NULL, NULL	},
{	NM_ITEM, (STRPTR)GetStr(MSG_01FA), (STRPTR)GetStr(MSG_025E), CHECKIT|MENUTOGGLE, 0L, (APTR)cp4prefsm2sound	},
{	NM_ITEM, (STRPTR)GetStr(MSG_01FB), (STRPTR)GetStr(MSG_0168), CHECKIT|MENUTOGGLE, 0L, (APTR)cp4prefsm2splim	},
{	NM_ITEM, (STRPTR)GetStr(MSG_01FC), (STRPTR)GetStr(MSG_0176), CHECKIT|MENUTOGGLE, 0L, (APTR)cp4prefsm2twoframe	},
{	NM_ITEM, (STRPTR)GetStr(MSG_018D), (STRPTR)GetStr(MSG_0162), CHECKIT|MENUTOGGLE, 0L, (APTR)cp4prefsm2swapjoy	},
{	NM_ITEM, (STRPTR)GetStr(MSG_01FD), (STRPTR)GetStr(MSG_0262), CHECKIT|MENUTOGGLE, 0L, (APTR)cp4prefsm2perc	},
{	NM_ITEM, (STRPTR)GetStr(MSG_0069), (STRPTR)GetStr(MSG_0263), CHECKIT|MENUTOGGLE, 0L, (APTR)cp4prefsm2iec },
{	NM_ITEM, (STRPTR)GetStr(MSG_01FE), (STRPTR)GetStr(MSG_025F), CHECKIT|MENUTOGGLE, 0L, (APTR)cp4prefsm2realtime },
{	NM_ITEM, (STRPTR)GetStr(MSG_0064), (STRPTR)GetStr(MSG_0158), CHECKIT|MENUTOGGLE, 0L, (APTR)cp4prefsm2sid },
{	NM_ITEM, (STRPTR)GetStr(MSG_0200), (STRPTR)GetStr(MSG_0266), CHECKIT|MENUTOGGLE, 0L, (APTR)cp4prefsm2osd },
{	NM_ITEM, (STRPTR)GetStr(MSG_0318), NULL, 0, 0L, NULL },
{	NM_SUB,  (STRPTR)GetStr(MSG_0319) ,(STRPTR)GetStr(MSG_0320), CHECKIT|MENUTOGGLE, 0L, (APTR)cp4prefsm2xpk },
{	NM_SUB,  (STRPTR)NM_BARLABEL, NULL, 0, 0L, NULL	},
{	NM_END, NULL, NULL, 0, 0L, NULL }
};
struct NewGadget cp4prefsNGad[] = {
{	3, 18, 116, 14, (UBYTE *)GetStr(MSG_01FF), NULL, GD_gscrmode, PLACETEXT_IN, NULL, (APTR)gscrmodeClicked },
{	122, 18, 342, 14, NULL, NULL, GD_gscrtxt, 0, NULL, NULL },
//{	3, 3, 26, 11, (UBYTE *)GetStr(MSG_01FA), NULL, GD_gsnd, PLACETEXT_RIGHT, NULL, (APTR)gsndClicked },
//{	119, 3, 26, 11, (UBYTE *)GetStr(MSG_018C), NULL, GD_gsplim, PLACETEXT_RIGHT, NULL, (APTR)gsplimClicked },
//{	235, 3, 26, 11, (UBYTE *)GetStr(MSG_01FC), NULL, GD_gtwoframe, PLACETEXT_RIGHT, NULL, (APTR)gtwoframeClicked },
//{	352, 3, 26, 11, (UBYTE *)GetStr(MSG_0200), NULL, GD_gswapjoy, PLACETEXT_RIGHT, NULL, (APTR)gswapjoyClicked },
//NEW
{	3, 2, 116, 14, NULL, NULL, GD_gdriveselcyc, 0, NULL, (APTR)gdriveselcycClicked },
{	122, 2, 312, 14, NULL, NULL, GD_gdrivetypecyc, 0, NULL, (APTR)gdrivetypecycClicked },
{	436, 2, 28, 14, (UBYTE *)"?", NULL, GD_gd64sel, PLACETEXT_IN, NULL, (APTR)gd64selClicked },
//NEW
{	3, 34, 116, 14, (UBYTE *)GetStr(MSG_0201), NULL, GD_gkeymap, PLACETEXT_IN, NULL, (APTR)gkeymapClicked },
{	122, 34, 342, 14, NULL, NULL, GD_gkeymaptxt, 0, NULL, NULL },
{	3, 51, 229, 14, NULL, NULL, GD_gc2ptxt, 0, NULL, NULL },
{	235, 51, 229, 14, NULL, NULL, GD_gc2pnametxt, 0, NULL, NULL },
{	235, 66, 229, 14, NULL, NULL, GD_gc2pauthortxt, 0, NULL, NULL },
{	3, 66, 229, 80, NULL, NULL, GD_gc2plist, 0, NULL, (APTR)gc2plistClicked },
{	235, 81, 229, 64, NULL, NULL, GD_gc2pinfo, 0, NULL, (APTR)gc2pinfoClicked },
{	3, 144, 110, 14, (UBYTE *)GetStr(MSG_0147), NULL, GD_gsave, PLACETEXT_IN, NULL, (APTR)gsaveClicked },
{	120, 144, 110, 14, (UBYTE *)GetStr(MSG_0202), NULL, GD_guse, PLACETEXT_IN, NULL, (APTR)guseClicked },
{	237, 144, 110, 14, (UBYTE *)GetStr(MSG_0148), NULL, GD_gcancel, PLACETEXT_IN, NULL, (APTR)gcancelClicked },
{	354, 144, 110, 14, (UBYTE *)GetStr(MSG_011C), NULL, GD_gquit, PLACETEXT_IN, NULL, (APTR)gquitClicked }
};
ULONG cp4prefsGTags[] = {
	(TAG_DONE),
	(GTTX_Text), (ULONG)" ", (GTTX_Border), TRUE, (TAG_DONE),
//	(GTCB_Checked), FALSE, (TAG_DONE),
//	(GTCB_Checked), FALSE, (TAG_DONE),
//	(TAG_DONE),
//	(TAG_DONE),
//NEW
	(GA_Disabled),TRUE,GTCY_Labels,(ULONG)cycdef,(TAG_DONE),
	(GA_Disabled),TRUE,GTCY_Labels,(ULONG)cycdef,(TAG_DONE),
	(GA_Disabled),TRUE,(TAG_DONE),
//NEW
	(TAG_DONE),
	(GTTX_Text), (ULONG)" ", (GTTX_Border), TRUE, (TAG_DONE),
	(GTTX_Text), (ULONG)GetStr(MSG_0203), (GTTX_Border), TRUE, GTTX_Justification, GTJ_CENTER,(TAG_DONE),
	(GTTX_Text), (ULONG)"-", (GTTX_Border), TRUE, (TAG_DONE),
	(GTTX_Text), (ULONG)"-", (GTTX_Border), TRUE, (TAG_DONE),
	(GTLV_Labels), (ULONG)&gc2plist0List, (GTLV_ShowSelected), NULL, (TAG_DONE),
	(GTLV_Labels), (ULONG)&gc2pinfo0List, (GTLV_ReadOnly), TRUE, (TAG_DONE),
	(TAG_DONE),
	(TAG_DONE),
	(TAG_DONE),
	(TAG_DONE)
};

	wtop=DefPrfTop;
	if(DefPrfTop==-1) { wa_top=TAG_IGNORE; wtop=0; }
	gc2plist0List.mlh_Head=(struct MinNode *)&gc2plist0Nodes[0];
	gc2plist0List.mlh_Tail=NULL;
	gc2plist0List.mlh_TailPred=(struct MinNode *)&gc2plist0Nodes[1];

	ComputeFont( cp4prefsWidth, cp4prefsHeight );
	memcpy(&myTextAttr,Font,sizeof(struct TextAttr));
	myTextFont=OpenFont(Font);

	ww = ComputeX( cp4prefsWidth );
	wh = ComputeY( cp4prefsHeight );

	if (( wleft + ww + OffX + Scr->WBorRight ) > Scr->Width ) wleft = Scr->Width - ww;
	if (( wtop + wh + OffY + Scr->WBorBottom ) > Scr->Height ) wtop = Scr->Height - wh;

	if ( ! ( g = CreateContext( &cp4prefsGList )))
		return( 1L );

	for( lc = 0, tc = 0; lc < cp4prefs_CNT; lc++ ) {

		CopyMem((char * )&cp4prefsNGad[ lc ], (char * )&ng, (long)sizeof( struct NewGadget ));

		ng.ng_VisualInfo = VisualInfo;
		ng.ng_TextAttr   = Font;
		ng.ng_LeftEdge   = OffX + ComputeX( ng.ng_LeftEdge );
		ng.ng_TopEdge    = OffY + ComputeY( ng.ng_TopEdge );
		ng.ng_Width      = ComputeX( ng.ng_Width );
		ng.ng_Height     = ComputeY( ng.ng_Height);

		if(lc==GD_gc2pinfo) c2pInfoWidth=ng.ng_Width;

		cp4prefsGadgets[ lc ] = g = CreateGadgetA((ULONG)cp4prefsGTypes[ lc ], g, &ng, ( struct TagItem * )&cp4prefsGTags[ tc ] );

		while( cp4prefsGTags[ tc ] ) tc += 2;
		tc++;

		if ( NOT g )
			return( 2L );
	}

	if ( ! ( cp4prefsMenus = CreateMenus( cp4prefsNewMenu, GTMN_FrontPen, 0L, TAG_DONE )))
		return( 3L );

	if(0!=addxpkmenus(cp4prefsMenus)) p4req1(NULL,P4_ERROR,"addxpkmenus");

	LayoutMenus(cp4prefsMenus,VisualInfo,GTMN_TextAttr,(ULONG)Scr->Font,GTMN_NewLookMenus,TRUE,TAG_DONE,0L);

	if ( ! ( cp4prefsWnd = OpenWindowTags( NULL,
				WA_Left,	wleft,
				wa_top,		wtop,
				WA_Width,	ww + OffX + Scr->WBorRight,
				WA_Height,	wh + OffY + Scr->WBorBottom,
				WA_IDCMP,	BUTTONIDCMP|
							TEXTIDCMP|
							CHECKBOXIDCMP|
							LISTVIEWIDCMP|
							IDCMP_CLOSEWINDOW|
							IDCMP_REFRESHWINDOW|
							IDCMP_MENUPICK,
				WA_Flags,	WFLG_DRAGBAR|
							WFLG_DEPTHGADGET|
							WFLG_CLOSEGADGET|
							WFLG_SMART_REFRESH|
							WFLG_ACTIVATE,
				WA_Gadgets,	(ULONG)cp4prefsGList,
				WA_Title,	(ULONG)GetStr(MSG_0204),
				WA_ScreenTitle,	(ULONG)GetStr(MSG_0205),
				WA_PubScreen,	(ULONG)Scr,
				WA_NewLookMenus,TRUE,
				TAG_DONE )))
	return( 4L );

	SetMenuStrip( cp4prefsWnd, cp4prefsMenus );
	GT_RefreshWindow( cp4prefsWnd, NULL );

	return( 0L );
}

static void Closecp4prefsWindow( void ) {
static char s[32];
	if ( cp4prefsMenus      ) {
		ClearMenuStrip( cp4prefsWnd );
		freexpkmenus(cp4prefsMenus);
		FreeMenus( cp4prefsMenus );
		cp4prefsMenus = NULL;	}
	if ( cp4prefsWnd        ) {
		DefPrfTop=cp4prefsWnd->TopEdge;
		DefPrfLeft=cp4prefsWnd->LeftEdge;
		sprintf(s,"%d",DefPrfTop);
		AddOption("PRFTOP",s);
		sprintf(s,"%d",DefPrfLeft);
		AddOption("PRFLEFT",s);
		CloseWindow( cp4prefsWnd );
		cp4prefsWnd = NULL;
	}
	if ( cp4prefsGList      ) {
		FreeGadgets( cp4prefsGList );
		cp4prefsGList = NULL;
	}
	CloseFont(myTextFont);
}

